<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>MLX90640 Heatmap + Camera Stream</title>
<style>
  body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; margin:12px; color:#111; }
  .row { display:flex; gap:12px; align-items:center; margin-bottom:8px; flex-wrap:wrap; }
  label { font-size:0.9rem; }
  #streams { display:flex; gap:12px; align-items:flex-start; flex-wrap:wrap; }
  #canvasWrap, #camWrap { border:1px solid #ddd; width:fit-content; padding:6px; background:#fafafa; }
  canvas { image-rendering: pixelated; display:block; background:#000; }
  #camStream { display:block; background:#000; object-fit:cover; }
  select,input { padding:6px; border-radius:6px; border:1px solid #ccc; }
  button { padding:8px 12px; border-radius:8px; border:1px solid #888; background:#eee; cursor:pointer; }
  .stat { font-weight:600; margin-left:8px; }
  #cameraStatus { margin-left:8px; font-weight:600; }
  @media (max-width:900px){
    #streams { flex-direction:column; }
  }
  /* small helper so the send controls don't wrap weirdly */
  #wsSendControls { display:flex; gap:8px; align-items:center; }
  #wsSendControls input { width:320px; }
  #wsAck { font-weight:600; color: #0a5; margin-left:12px; }
  #wsAck.err { color: #a00; }
</style>
</head>
<body>
<h2>MLX90640 Heatmap (binary float32 only) + Camera Stream</h2>

<div class="row">
  <label>WebSocket URL
    <input id="wsUrl" style="width:320px" value="">
  </label>
  <button id="btnConnect">Connect</button>
  <span id="status" style="margin-left:12px">Status: <strong>idle</strong></span>
  <!-- Acknowledgement area for verification replies -->
  <span id="wsAck">Last ack: <strong>-</strong></span>
</div>

<div class="row">
  <label><input type="checkbox" id="useRef"> Use Temp Ref</label>
  <label>Baseline <input id="baseline" type="number" step="0.1" value="30" style="width:90px"></label>
  <label>Range <input id="range" type="number" step="0.1" value="20" style="width:90px"></label>

  <label>Colormap
    <select id="cmap">
      <option value="turbo" selected>turbo</option>
      <option value="thermal">thermal</option>
      <option value="grayscale">grayscale</option>
      <option value="iron">iron</option>
    </select>
  </label>

  <label>Pixel scale
    <select id="scale"><option>4</option><option>6</option><option selected>8</option><option>10</option><option>12</option><option>15</option></select>
  </label>

  <div style="margin-left:8px">FPS: <span id="fps" class="stat">0</span></div>
  <div style="margin-left:8px">Min and Max temp in deg C <span id="lastMin" class="stat">-</span> / <span id="lastMax" class="stat">-</span></div>
</div>

<!-- New camera controls -->
<div class="row">
  <label>Camera URL
    <input id="camUrl" style="width:320px" value="">
  </label>
  <button id="btnCamToggle">Connect Camera</button>
  <span id="cameraStatus">Camera: <strong>idle</strong></span>
</div>

<!-- WebSocket send controls (arbitrary payload) -->
<div class="row" id="wsSendControls">
  <button id="btnOn">Turn on valve</button>
  <button id="btnOff">Turn off valve</button>
  <button id="btnFeed">Feed</button>
</div>

<div id="streams">
  <div id="canvasWrap">
    <canvas id="heatmap"></canvas>
  </div>

  <div id="camWrap">
    <img id="camStream" alt="camera stream (connect to view)">
  </div>
</div>

<script>
(() => {
  // ---- Layout and canvas ----
  let cols = 32, rows = 24; // defaults
  const expectedCount = () => cols * rows;
  const expectedBytes = () => expectedCount() * 4; // float32
  const canvas = document.getElementById('heatmap');
  const ctx = canvas.getContext('2d');
  const smallCanvas = document.createElement('canvas');
  const smallCtx = smallCanvas.getContext('2d');

  // ---- UI elements ----
  const fpsEl = document.getElementById('fps');
  const statusEl = document.getElementById('status');
  const lastMinEl = document.getElementById('lastMin');
  const lastMaxEl = document.getElementById('lastMax');
  const scaleSel = document.getElementById('scale');
  const useRefEl = document.getElementById('useRef');
  const baselineEl = document.getElementById('baseline');
  const rangeEl = document.getElementById('range');
  const cmapSel = document.getElementById('cmap');

  // Acknowledgement UI for server replies
  const wsAckEl = document.getElementById('wsAck');

  // Camera UI
  const camUrlInput = document.getElementById('camUrl');
  const camBtn = document.getElementById('btnCamToggle');
  const camStatusEl = document.getElementById('cameraStatus');
  const camImg = document.getElementById('camStream');
  let camConnected = false;

  // WS send UI
  const ON_VALVE = document.getElementById('btnOn');
  const OFF_VALVE = document.getElementById('btnOff');
  const FEED = document.getElementById('btnFeed');

  // default WS url (tries same host /ws)
  /*
  const defaultWsUrl = (() => {
    if (location.protocol.startsWith('http')) {
      return `${location.protocol.replace('http','ws')}//${location.hostname}${location.port ? ':'+location.port : ''}/ws`;
    }
    return 'ws://heatmap/ws';
  })();
  /*
  

  // default camera URL
  /*
  const defaultCamUrl = (() => {
    if (location.protocol.startsWith('http')) {
      const proto = location.protocol;
      return `${proto}//${location.hostname}:81/stream`;
    }
    return 'http://cam_stream:81/stream';
  })();
  */
  camUrlInput.value = 'http://cam_stream:81/stream';
  document.getElementById('wsUrl').value = 'ws://heatmap/ws';
  let ws = null;
  let reconnectDelay = 1000;
  let reconnectTimer = null;
  let processing = false;        // if true, drop incoming frames
  let lastFpsUpdate = performance.now();
  let framesSinceLast = 0;
  let scale = parseInt(scaleSel.value, 10);

  function setupCanvases() {
    smallCanvas.width = cols;
    smallCanvas.height = rows;
    canvas.width = cols * scale;
    canvas.height = rows * scale;
    ctx.imageSmoothingEnabled = false;
    smallCtx.imageSmoothingEnabled = false;
    camImg.style.height = canvas.height + 'px';
    camImg.style.maxWidth = '420px';
  }
  setupCanvases();

  function setStatus(text) {
    statusEl.innerHTML = 'Status: <strong>' + text + '</strong>';
  }
  function setCameraStatus(text) {
    camStatusEl.innerHTML = 'Camera: <strong>' + text + '</strong>';
  }
  function setWsAck(text, isError) {
    wsAckEl.classList.toggle('err', !!isError);
    wsAckEl.innerHTML = 'Last ack: <strong>' + text + '</strong>';
  }

  // ---- provided colormap functions ----
  function lerp(a,b,t){return a + (b-a)*t;}
  function getColorForValue(val, vminLocal, vmaxLocal, cmap) {
    if (!isFinite(val)) return [0,0,0,255];
    if (vminLocal === vmaxLocal) vminLocal -= 0.5, vmaxLocal += 0.5;
    const t = Math.max(0, Math.min(1, (val - vminLocal) / (vmaxLocal - vminLocal)));
    if (cmap === 'grayscale') {
      const g = Math.round(255 * t);
      return [g,g,g,255];
    }
    if (cmap === 'thermal') {
      if (t < 0.25) { const tt = t/0.25; return [0, Math.round(255*tt), Math.round(255*(0.5+0.5*tt)),255]; }
      if (t < 0.5)  { const tt = (t-0.25)/0.25; return [Math.round(255*tt), 255, Math.round(255*(1-0.5*tt)),255]; }
      if (t < 0.75) { const tt = (t-0.5)/0.25; return [255, Math.round(255*(1-tt)), 0,255]; }
      { const tt = (t-0.75)/0.25; return [255, Math.round(128*(1-tt)), Math.round(128*(1-tt)),255]; }
    }
    if (cmap === 'iron') {
      const r = Math.round(255 * Math.pow(t, 1.5));
      const g = Math.round(200 * Math.pow(t, 1.2));
      const b = Math.round(100 * t);
      return [r,g,b,255];
    }
    // turbo-ish (approx)
    const stops = [
      [0.0, [48,18,59]],
      [0.25,[18,102,173]],
      [0.5, [28,179,128]],
      [0.75,[248,182,35]],
      [1.0, [181,0,0]]
    ];
    for (let i=0;i<stops.length-1;i++){
      const t0 = stops[i][0], t1 = stops[i+1][0];
      if (t >= t0 && t <= t1){
        const local = (t - t0) / (t1 - t0);
        const c0 = stops[i][1], c1 = stops[i+1][1];
        return [ Math.round(lerp(c0[0],c1[0],local)),
                 Math.round(lerp(c0[1],c1[1],local)),
                 Math.round(lerp(c0[2],c1[2],local)), 255 ];
      }
    }
    return [255,0,255,255];
  }

  function drawFloatFrame(floats) {
    if (processing) return; // drop frames if still drawing previous
    processing = true;

    // compute observed min/max (for autoscale display)
    let obsMin = Infinity, obsMax = -Infinity;
    for (let i = 0; i < floats.length; i++) {
      const v = floats[i];
      if (isFinite(v)) {
        if (v < obsMin) obsMin = v;
        if (v > obsMax) obsMax = v;
      }
    }
    lastMinEl.textContent = isFinite(obsMin) ? obsMin.toFixed(2) : '-';
    lastMaxEl.textContent = isFinite(obsMax) ? obsMax.toFixed(2) : '-';

    // choose vmin/vmax
    let vmin, vmax;
    if (useRefEl.checked) {
      const baseline = parseFloat(baselineEl.value);
      const rangeVal = parseFloat(rangeEl.value);
      vmin = isFinite(baseline) ? baseline : (isFinite(obsMin) ? obsMin : 0);
      vmax = isFinite(rangeVal) ? (vmin + rangeVal) : (isFinite(obsMax) ? obsMax : (vmin + 10));
    } else {
      // per-frame autoscale
      vmin = isFinite(obsMin) ? obsMin : 0;
      vmax = isFinite(obsMax) ? obsMax : (vmin + 1);
      if (vmax <= vmin) vmax = vmin + 1;
    }
    const cmap = cmapSel.value || 'turbo';

    // build image in offscreen canvas at native sensor resolution
    const img = smallCtx.createImageData(cols, rows);
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        const idx = r * cols + c;
        const v = floats[idx];
        const col = getColorForValue(v, vmin, vmax, cmap);
        const p = (r * cols + c) * 4;
        img.data[p + 0] = col[0];
        img.data[p + 1] = col[1];
        img.data[p + 2] = col[2];
        img.data[p + 3] = col[3];
      }
    }
    smallCtx.putImageData(img, 0, 0);

    // upscale to visible canvas (nearest-neighbor) and flip horizontally
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.save();
    ctx.imageSmoothingEnabled = false;
    ctx.translate(canvas.width, 0);
    ctx.scale(-1, 1);
    ctx.drawImage(smallCanvas, 0, 0, canvas.width, canvas.height);
    ctx.restore();

    // FPS
    framesSinceLast++;
    const now = performance.now();
    if (now - lastFpsUpdate >= 500) {
      fpsEl.textContent = ((framesSinceLast * 1000) / (now - lastFpsUpdate)).toFixed(1);
      framesSinceLast = 0;
      lastFpsUpdate = now;
    }

    processing = false;
  }

  // ---- WebSocket: binary-only payloads + JSON ack handling ----
  function scheduleReconnect(url) {
    if (reconnectTimer) return; // one timer only
    setStatus(`reconnecting in ${reconnectDelay/1000}s`);
    reconnectTimer = setTimeout(() => {
      reconnectTimer = null;
      connect(url);
      reconnectDelay = Math.min(30000, Math.floor(reconnectDelay * 1.5));
    }, reconnectDelay);
  }

  function connect(url) {
  
    if (reconnectTimer) {
	
		clearTimeout(reconnectTimer);
		reconnectTimer = null; 
	}
	
    if (ws) { 
		try {
		ws.onopen = ws.onmessage = ws.onclose = ws.onerror = null;
		ws.close();
		} 
		catch(e){
		} 
		ws = null; 
	}

    setStatus('connecting');
    ws = new WebSocket(url);
    ws.binaryType = 'arraybuffer';

    ws.onopen = () => {
      reconnectDelay = 1000;
      setStatus('connected');
      // optional handshake
      try { ws.send('CLIENT_READY'); } catch(e) {}
    };

    ws.onerror = (err) => {
      console.warn('WS error', err);
      setStatus('error');
    };

    ws.onclose = (ev) => {
      setStatus('closed');
      scheduleReconnect(url);
    };

    ws.onmessage = async (ev) => {
      // Drop if busy painting
      if (processing) return;

      // If text message and starts with META:, use it to set layout.
      if (typeof ev.data === 'string') {
        const txt = ev.data.trim();

        // JSON verification reply handling:
        if (txt.startsWith('{')) {
          try {
            const obj = JSON.parse(txt);
            // If a verification reply with "status" exists, show ack.
            if (obj && obj.status) {
              if (obj.status === 'ok') {
                let detail = obj.cmd ? obj.cmd : 'ok';
                if (obj.state) detail += ' ' + obj.state;
                if (obj.amount) detail += ' amt=' + obj.amount;
                setWsAck('OK: ' + detail, false);
              } else {
                setWsAck('ERR: ' + (obj.error || 'unknown'), true);
              }
              // don't treat JSON replies as sensor data; return early
              return;
            }
          } catch (e) {
            // not JSON, continue to META/csv handling below
          }
        }

        if (txt.startsWith('META:')) {
          const parts = txt.substring(5).split(',');
          if (parts.length >= 2) {
            const c = parseInt(parts[0], 10), r = parseInt(parts[1], 10);
            if (Number.isInteger(c) && Number.isInteger(r)) {
              cols = c; rows = r; setupCanvases();
              console.log('META applied:', cols, 'x', rows);
            }
          }
        }
        // ignore other text formats (CSV support intentionally removed)
        return;
      }

      // Blob or ArrayBuffer - only handle binary float32 of expected size
      let arrBuf = null;
      if (ev.data instanceof Blob) {
        if (ev.data.size !== expectedBytes()) {
          console.warn('Ignoring Blob of unexpected size', ev.data.size);
          return;
        }
        arrBuf = await ev.data.arrayBuffer();
      } else if (ev.data instanceof ArrayBuffer) {
        if (ev.data.byteLength !== expectedBytes()) {
          console.warn('Ignoring ArrayBuffer of unexpected length', ev.data.byteLength);
          return;
        }
        arrBuf = ev.data;
      } else {
        // unknown type - ignore
        return;
      }

      // ----- FLOAT ARRAY RECEIVED HERE -----
      // This block receives binary frames (ArrayBuffer or Blob) that contain
      // little-endian float32 values representing the MLX90640 sensor.
      // We validate expected size, decode into a Float32Array and pass to drawFloatFrame().
      // -------------------------------------------------------------------------------
      const dv = new DataView(arrBuf);
      const floats = new Float32Array(expectedCount());
      for (let i = 0; i < floats.length; i++) {
        floats[i] = dv.getFloat32(i * 4, true); // littleEndian = true
      }
      drawFloatFrame(floats);
    };
  }

  // ---- Camera connect/disconnect logic ----
  function connectCamera(url) {
    if (!url) return alert('Enter Camera URL');
    camImg.src = url;
    setCameraStatus('connecting');

    camImg.onload = () => {
      camConnected = true;
      setCameraStatus('connected');
      camBtn.textContent = 'Disconnect Camera';
    };
    camImg.onerror = () => {
      camConnected = false;
      setCameraStatus('error');
      camBtn.textContent = 'Connect Camera';
    };
  }
  function disconnectCamera() {
    camImg.src = '';
    camImg.onload = null;
    camImg.onerror = null;
    camConnected = false;
    setCameraStatus('idle');
    camBtn.textContent = 'Connect Camera';
  }

  // ----- send helpers (normalize to JSON text) -----
  function sendPayloadToWs(payload) {
    // payload can be object or string; normalize
    let text;
    if (typeof payload === 'object') {
      text = JSON.stringify(payload);
    } else {
      text = String(payload);
    }

    // if main WS is open, send there
    try {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(text);
        setStatus('sent: ' + (text.length > 120 ? text.slice(0,120) + 'â€¦' : text));
        return;
      }
    } catch (e) {
      console.warn('Error sending on existing ws', e);
    }

    // fallback: one-shot temporary WS, show reply (if any) in ack UI
    const target = (document.getElementById('wsUrl').value || 'ws://sample/ws').trim();
    let tmp;
    try {
      tmp = new WebSocket(target);
    } catch (err) {
      alert('Failed to create temporary WebSocket. Check URL.');
      return;
    }

    let gotReply = false;
    const to = setTimeout(() => {
      if (!gotReply) {
        tmp.close();
        setWsAck('no reply (temp)', true);
      }
    }, 3000);

    tmp.onopen = () => {
      try { tmp.send(text); setStatus('sent (temp): ' + text); } catch (e) { alert('temp send failed'); clearTimeout(to); tmp.close(); }
    };
    tmp.onmessage = (ev) => {
      gotReply = true;
      clearTimeout(to);
      if (typeof ev.data === 'string') {
        try {
          const obj = JSON.parse(ev.data);
          if (obj && obj.status) {
            if (obj.status === 'ok') {
              let detail = obj.cmd ? obj.cmd : 'ok';
              if (obj.state) detail += ' ' + obj.state;
              setWsAck('OK: ' + detail, false);
            } else {
              setWsAck('ERR: ' + (obj.error || 'unknown'), true);
            }
          } else {
            setWsAck(ev.data, false);
          }
        } catch (e) {
          setWsAck(ev.data, false);
        }
      } else {
        setWsAck('(binary reply)', false);
      }
      tmp.close();
    };
    tmp.onerror = () => { clearTimeout(to); tmp.close(); setWsAck('temp ws error', true); };
    tmp.onclose = () => { clearTimeout(to); };
  }

  // Button handlers send structured JSON (recommended)
  ON_VALVE.addEventListener('click', () => {
    sendPayloadToWs({ cmd: 'valve', state: 'on' });
  });
  OFF_VALVE.addEventListener('click', () => {
    sendPayloadToWs({ cmd: 'valve', state: 'off' });
  });
  FEED.addEventListener('click', () => {
    sendPayloadToWs({ cmd: 'feed', amount: 1 });
  });

  // UI wiring
  document.getElementById('btnConnect').addEventListener('click', () => {
    const url = document.getElementById('wsUrl').value.trim();
    if (!url) return alert('Enter WebSocket URL');
    reconnectDelay = 1000;
    connect(url);
  });

  camBtn.addEventListener('click', () => {
    if (!camConnected) {
      const url = camUrlInput.value.trim();
      if (!url) return alert('Enter Camera URL');
      connectCamera(url);
    } else {
      disconnectCamera();
    }
  });

  scaleSel.addEventListener('change', () => {
    scale = parseInt(scaleSel.value, 10) || 8;
    setupCanvases();
  });

  window.addEventListener('resize', () => {
    camImg.style.height = canvas.height + 'px';
  });

  window.addEventListener('beforeunload', () => {
    if (ws) try { ws.close(); } catch(e){}
    disconnectCamera();
  });

  // auto-connect once to WS (camera left to user)
  connect(document.getElementById('wsUrl').value);
})();
</script>
</body>
</html>
